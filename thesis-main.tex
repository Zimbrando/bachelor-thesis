\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{Monitoraggio Ed Automazione Della Distribuzione Di Software Complessi}
\author{Marco Sternini}
\date{\today}
\subject{Programmazione ad oggetti}
\supervisor{Dott. Danilo Pianini}
\cosupervisor{Dott.sa Martina Baiardi}
\session{III}
\academicyear{2022-2023}

% Definition of acronyms
\acrodef{vm}[VM]{Virtual Machine}
\acrodef{cicd}[CI/CD]{Continuous Integration Continuous Delivery}
\acrodef{cli}[CLI]{Command Line Interface}
\acrodef{jvm}[JVM]{Java Virtual Machine}
\acrodef{jre}[JRE]{Java Runtime Environment}
\acrodef{aur}[AUR]{Arch User Repository}
\acrodef{dsl}[DSL]{Domain-Specific Language}

\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Max 2000 characters, strict.
\end{abstract}

\begin{dedication} % this is optional
Optional. Max a few lines.
\end{dedication}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

%----------------------------------------------------------------------------------------
\tableofcontents   
\listoffigures     % (optional) comment if empty
\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{Introduzione}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

Introduzione 

(Il problema, software oggigiorno, l'importanza della qualità del software e altre caratteristiche di ingegneria del software, come automatizzare migliora la qualità eliminando l'intervento umano)

s
\section{Contesto}

(Un'introduzione teorica degli elementi sotto elencati, cosa servono, esempi di software che risolvono questo problema, evoluzione di questi negli ultimi anni )

\subsection{Build automation}
\subsection{Continuous integration}
\subsection{Continuous delivery}
\paragraph{Pipeline}

\subsection{Alchemist}

(Cos'è alchemist, utilizzo, tecnologie utilizzate, architettura, progettazione)

\section{Obiettivi}

\paragraph{Struttura della tesi}

La struttura di questo paper

\chapter{Analisi}

Il progetto si pone tre principali obiettivi:
\begin{itemize}
	\setlength\itemsep{0.8em}
	\item La generazione automatica di pacchetti di installazione multi-piattaforma \\ con \ac{jre} integrato
	\item La pubblicazione automatica dei rilasci all'interno dell'\ac{aur}
	\item Lo sviluppo di una \ac{cli} per interagire con il simulatore
\end{itemize}
Con integrazione di un \ac{jre} si intende il supplemento di una \ac{jvm}, frequentemente ridotta di dimensioni, all'interno del pacchetto di installazione.
L'utente potrebbe non aver alcun \ac{jre} installato sul proprio dispositivo, oppure quello presente potrebbe essere obsoleto. Inserendo una macchina virtuale Java: si fornisce uno specifico ambiente di esecuzione, eliminando potenziali problemi di compatibilità e si agevola la procedura di installazione per l'end-user. L'avvio dell'applicazione è delegato ad un file eseguibile nativo della piattaforma. [Trasparenza riguardo l'utilizzo di una JVM, comodità di un file eseguibile nativo]

\section{Requisiti}

Il codice di Alchemist è ospitato nella piattaforma GitHub ed utilizza la funzionalità denominata GitHub Actions per orchestrare un flusso di integrazione e rilascio continuo. 

\paragraph{Requisiti funzionali}

Le funzionalità richieste si possono classificare in due gruppi distinti: uno di questi contiene tutto ciò che concerne l'esperienza dell'utente finale, mentre il secondo descrive le funzionalità dal punto di vista degli sviluppatori e contributori di Alchemist.
\begin{itemize}
	\item \textbf{Multi-piattaforma}: Alchemist deve essere installabile sui maggiori sistemi operativi in circolazione come Windows, MacOS e le principali distribuzioni Linux (Debian, Fedora, Arch).
	\item \textbf{Usabilità}: il simulatore deve fornire un'interfaccia \ac{cli} completa, ovvero che permetta l'utilizzo di tutte le sue funzionalità.
\end{itemize}

I requisiti del gruppo successivo sono accumunabili per il loro scopo, vale a dire l'automazione. L'introduzione di processi automatici minimizza la probabilità di errare eliminando l'intervento umano. 

\begin{itemize}
	\item \textbf{Automazione dei pacchetti}: la generazione dei pacchetti di installazione deve essere automatica e configurabile
	\item \textbf{Automazione della distribuzione}: il rilascio di una nuova versione deve fornire i pacchetti all'interno di GitHub e pubblicare l'aggiornamento nell'\ac{aur}.
	\item \textbf{Verifica funzionamento}: entrambi i processi descritti precedentemente devono essere corredati da verifiche del loro funzionamento e devono bloccare la procedura di rilascio nell'eventualità siano presenti errori.
\end{itemize}

\paragraph{Requisiti non funzionali}

\begin{itemize}
	\item Trattandosi Alchemist di un software attualmente ed in continuo sviluppo, è auspicabile l'utilizzo degli strumenti già integrati all'interno del repositorio. L'integrazione di nuovi applicativi deve essere eseguita solo se strettamente necessaria.
	\item La pipeline aggiornata deve assicurare tempi di esecuzione simili alla versione precedente.
	\item L'interfaccia a linea di comando per interagire con il simulatore deve essere autoesplicativa.
\end{itemize}

\section{Strumenti}

\subsection{Gradle}

Strumento open source di build automation configurabile attraverso due diversi \ac{dsl}: Groovy o Kotlin. Gradle utilizza un grafo aciclico diretto per determinare l'ordine di esecuzione dei processi. Supporta lo sviluppo incrementale essendo capace di riconoscere quali processi rieseguire a fronte di una modifica alla configurazione.
Il procedimento di build si divide in tre fasi distinte.
\paragraph{Fase di inizializzazione} In primo luogo Gradle crea un istanza di Settings che organizza l'architettura del progetto. Attraverso questo file, di nome "settings.gradle", lo sviluppatore stabilisce il progetto radice e tutti gli eventuali progetti figli. 
\paragraph{Fase di configurazione} Successivamente tutti i file di configurazione build.gradle (del progetto radice e tutti i sotto-progetti) vengono analizzati per costruire il grafo dei task. Un task rappresenta un'unità atomica di esecuzione.
\paragraph{Fase di esecuzione} Infine, Gradle esegue i task richiesti considerando le dipendenze descritte nel grafo generato dalla fase precedente.

\subsection{Github actions}

\subsection{Arch User Repository}

\chapter{Design}

\section{Architettura e macrostruttura}
Interazione tra gradle e github actions, l’attuale struttura della pipeline di alchemist, le aggiunte che sono state fatte..

\section{Impacchettamento}
Discussione sulla scelta del software di packaging, vantaggi / svantaggi

\subsection{GraalVM}

\subsection{JPackage}

\subsection{Valutazioni}

\section{Flusso di rilascio}
Il processo del rilascio di una release nuova di alchemist, dalle automazioni già presenti alle integrazioni di testing, impacchettamento e pubblicazione
\subsection{Rilascio}

\subsection{Pubblicazione}

\section{User experience}
Discussione design della terza parte

\subsection{CLI e GUI}

\subsection{Design CLI}

\chapter{Implementazione}

\begin{itemize}
	\item Particolari design nell'interfaccia CLI
	\item Esempi
\end{itemize}

\chapter{Conclusioni}

\section{Sviluppi futuri}

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter

\nocite{*} % comment this to only show the referenced entries from the .bib file

\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}