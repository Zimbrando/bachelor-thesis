%!TEX root = ../thesis-main.tex

% Percorso implementativo:
% 	V- jpackage e le opzioni in dettaglio
%  	V- jlink e jdeps
%   V- il plugin gradle per operare con jpackage
%   V- la necessità di estendere con jpackageFull
%   - inserimento dei test e della release dei pacchetti
%   - le operazioni per la distribuzione e il test di queste (AUR)

\chapter{Implementazione}

Nel seguente capitolo è illustrato il percorso e le relative scelte implementative effettuate per soddisfare i requisiti posti dal progetto. Successivamente, valuterò il lavoro svolto considerando i requisiti posti durante l'analisi.

\section{Pacchettizzazione e meta-dati}

\subsection{Pacchettizzazione}
Come discusso nelle precedenti sezioni riguardanti lo strumento jpackage (in particolare sezione \ref{sec:design-jpackage}), esso presenta una notevole quantità di opzioni sia inerenti l'aspetto estetico (nome dell'applicazione, icona, copyright ed altri), sia riguardo aspetti tecnici che possono contraddistinguere la qualità del pacchetto di installazione. Inoltre, attraverso l'\textit{override} delle impostazioni è possibile ottenere un controllo accurato del processo di generazione dei pacchetti, consentendo una totale personalizzazione dell'output generato. Ciò è ottenibile sfruttando due opzioni fornite dall'interfaccia del comando stesso. Eseguendo il programma fornendo l'opzione \texttt{temp}, lo strumento inserisce all'interno della cartella designata i file temporanei utilizzati nel processo (figura \ref{fig:jpackage-process-detailed}). Questi sono i file di configurazione generati dal programma, i quali sono successivamente processati dai toolset specifici per la piattaforma di destinazione per generare il pacchetto. In particolare, ``WiX" è richiesto per la produzione dei pacchetti destinati a Windows, ``XCode" relativamente a MacOs, mentre ``rpm-build" e ``fakeroot" sono necessari per generare rispettivamente pacchetti rpm e deb. La funzionalità di override consiste nel fornire a jpackage i file di configurazione dei toolset, lo strumento pone quest'ultimi sempre come prioritari per stabilire la configurazione del pacchetto in output. Mediante i file temporanei si ottiene una base di partenza nella quale modificare o inserire parametri aggiuntivi. Questa funzionalità ha permesso di soddisfare il requisito \textbf{plug and play}, in particolare è stato implementato l'inserimento automatico dell'eseguibile di Alchemist nella variabile d'ambiente ``Path". In questo modo, l'applicazione è disponibile immediatamente dopo l'installazione e può essere utilizzata da riga di comando senza ulteriori configurazioni.

La capacità di sovrascrivere le configurazioni dei toolset ha permesso di ottenere un maggior controllo sulla forma e comportamento dell'installazione dei pacchetti. Le successive opzioni di carattere tecnico si occupano di modificare il contenuto di questi. In quest'ottica è necessario introdurre altri due strumenti del \ac{jdk}: (i) \texttt{jlink}, strumento delegato alla produzione della \textit{runtime-image} inserita all'interno del pacchetto e (ii) \texttt{jdeps}, comando adibito all'analisi delle dipendenze. Il primo ha la peculiarità di consentire la creazione di ambienti java personalizzati contenenti moduli specifici, riducendo così le dimensioni della runtime-image nel complesso e incrementando le prestazioni dell'applicazione. Per creare una runtime-image ad hoc contenente il minimo necessario ad eseguire l'applicazione si utilizza lo strumento jdeps. In sintesi la generazione del pacchetto richiede l'utilizzo dei tre strumenti consecutivamente come esposto di seguito:
\begin{enumerate}
	\item \texttt{jdeps}, analizza l'archivio contenente l'applicazione e restituisce i moduli java necessari per il corretto funzionamento di essa,
	\item \texttt{jlink}, utilizza i moduli evidenziati da jdeps per creare una runtime-image personalizzata di dimensioni ridotte,
	\item \texttt{jpackage}, utilizza la runtime-image creata precedentemente assieme all'ar\-chi\-vio dell'applicazione per generare il pacchetto: l'application-image.
\end{enumerate}

\lstinputlisting[float,language=Bash,label={lst:jlink-runtime-image-creation}, caption={Comandi eseguiti per creare un java-runtime di dimensioni ridotte}]{listings/jpackage-jlink.sh}

\def\arraystretch{1.5}
\begin{table}[htb]
	\label{fig:jpackage-options}
	\begin{tabular}{|l|l|l|}
		\hline
		\rowcolor[HTML]{ECF4FF} 
		\multicolumn{1}{|c|}{\cellcolor[HTML]{ECF4FF}{\ul Opzione}} &
		\multicolumn{1}{|c|}{\cellcolor[HTML]{ECF4FF}{\ul Funzionalità}} &
		\multicolumn{1}{|c|}{\cellcolor[HTML]{ECF4FF}{\ul Eventuali parametri}} \\ \hline
		\texttt{--type} &
		Tipologia di pacchetto in output &
		\begin{tabular}[c]{@{}l@{}}rpm, deb, exe, msi, \\ pkg, dmg\end{tabular} \\ \hline
		\texttt{--input} &
		\begin{tabular}[c]{@{}l@{}}Directory contenente i file\\ da impacchettare\end{tabular} &
		Percorso alla directory \\ \hline
		\texttt{--main-jar} &
		\begin{tabular}[c]{@{}l@{}}L'archivio JAR principale\\ contenete la classe principale\end{tabular} &
		Percorso del JAR \\ \hline
		\texttt{--main-class} &
		\begin{tabular}[c]{@{}l@{}}La classe che contiene la \\ funzione di avvio\end{tabular} &
		Nome della classe \\ \hline
		\texttt{--add-modules} &
		\begin{tabular}[c]{@{}l@{}}I moduli integrati nel\\ runtime-image generato da \\ jlink\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}Lista dei moduli separata\\ da ','\end{tabular} \\ \hline
		\texttt{--jlink-options} &
		\begin{tabular}[c]{@{}l@{}}Ulteriori opzioni per\\ l'esecuzione di jlink\end{tabular} &
		Lista delle opzioni \\ 
	\end{tabular}
	\caption{Tabella che elenca le principali opzioni tecniche del comando \texttt{jpackage}}
\end{table}

I comandi utilizzati nel processo sono indicati nel listato \ref{lst:jlink-runtime-image-creation}. In particolare l'esecuzione di jdeps coinvolge le seguenti opzioni: \texttt{--print-module-deps} indica di restituire un output conforme all'input ri\-chie\-sto da jlink,\texttt{--add-modules} aggiunge attraverso la costante ``ALL-MODULE-PATH" tutti i moduli per eseguire l'analisi.



Il comando jpackage completo utilizzando le opzioni descritte nella tabella \ref{fig:jpackage-options} è il seguente:

\texttt{\\ jpackage --input build/package-input \\ \tab\tab --main-jar alchemist-full-VERSION.jar \\ \tab\tab --main-class it.unibo.alchemist.Alchemist \\ \tab\tab --add-modules \$DEPENDENCIES \\ \tab\tab --jlink-options no-header-file, no-man-pages \\}

%Confronto, scelta tra i due full o solo moduli, il guadagno in %, perché in alchemist è così poco ed in altre applicazioni potrebbe essere molto maggiore, analisi della reflection step necessario al funzionamento

Il risultato ottenuto è interessante, la differenza tra i due dati è buona.
Il simulatore Alchemist è estendibile, ed ottiene questa caratteristica sfruttando la reflection.

%------------------------------------------------

\paragraph{Plugin} Il design elaborato nel capitolo precedente evidenziava la necessità di un task \textit{wrapper} che incapsulasse le opzioni e funzionalità di jpackage. La versatilità offerta da Gradle ha permesso di ottenere il risultato voluto attraverso \textit{jpackage-gradle-plugin}\footnote{https://github.com/petr-panteleyev/jpackage-gradle-plugin}: un plugin sviluppato dalla comunità. Questo componente introduce un tipo di task \texttt{JPackageTask} capace di: (i) configurare tutte le opzioni supportate da jpackage per qualsiasi versione del \ac{jdk}, (ii) definire blocchi di codice eseguiti solamente su un sistema operativo specifico e (iii) testare le configurazioni attraverso la modalità \textit{dry run}. Tuttavia, il plugin introdotto non risolve uno dei limiti di jpackage evidenziato in fase di analisi: la creazione di un solo pacchetto per l'esecuzione. Per far fronte a questa limitazione, ho creato una tipologia personalizzata (vedi listato \ref{lst:custom-jpackage-task}) che estende quella fornita dal plugin. In questo modo, ho potuto modificare il comportamento del task, intervenendo specificamente sul metodo contrassegnato con \texttt{@TaskAction}. Tale metodo contiene il codice che viene eseguito quando il task viene invocato da riga di comando, avviandone l'esecuzione.

\lstinputlisting[float,language=Kotlin,label={lst:custom-jpackage-task}, caption={Definizione di un tipo di task personalizzato}]{listings/custom-jpackage-task.kt}

\subsection{Meta-dati}

Nei paragrafi seguenti saranno esposte le tecniche utilizzate per garantire l'utilizzo di meta-dati conformi ai requisiti dei repository di destinazione.

\paragraph{Template} I meta-dati associati ai pacchetti presentano attributi statici e altri dinamici. Prendendo in esame il file PKGBUILD, parametri come il nome, la descrizione o le dipendenze non richiedono modifiche tra versioni differenti del software. La modifica di questi è a discrezione dello sviluppatore, il quale come manutentore si occupa per esempio di aggiornare le dipendenze manualmente o modificare le funzioni nel caso dovesse essere necessario. I parametri considerati dinamici invece, richiedono costanti modifiche perché direttamente o indirettamente sono legati alla versione per la quale si sta preparando lo script. Di seguito sono elencati i fondamentali:
\begin{itemize}
	\item la \textbf{versione}, seppure è possibile delegare il calcolo alla funzione \textit{pkgver}, quest'ultima non è ottenibile se non utilizzando il build system. Essendo necessaria l'interazione con Gradle, la scrittura di questo parametro deve essere necessariamente eseguita dinamicamente attraverso esso.
	\item la \textbf{sorgente}, ossia l'URL localizzante il pacchetto in rete. L'aggiornamento ad una nuova versione richiede l'utilizzo del pacchetto contenente la nuova versione del software, ragion per cui l'URL sarà differente.
	\item il \textbf{checksum}, ovvero il codice hash legato alla sorgente. È utilizzato da makepkg per assicurarsi che il pacchetto installato non sia stato sostituito da un attore malevolo, una volta ottenuta la sorgente, ricalcola il checksum e lo confronta con quello fornito dallo script.
\end{itemize}
Mediante l'utilizzo di file detti template è possibile costruire dinamicamente i meta-dati mantenendo una struttura statica facilmente aggiornabile. In particolare, il template del file PKGBUILD contiene tutti i parametri statici correttamente assegnati, mentre quelli dinamici sono identificati attraverso l'inserimento di caratteri speciali inutilizzati. Il task \texttt{generatePKGBUILD} legge il file e sostituisce i caratteri con i valori corretti ottenendo come risultato il PKGBUILD conforme e compatibile con la versione corrente del software. A differenza di Winget, il file PKGBUILD permette di utilizzare una sorgente locale (un percorso nel filesystem). Ciò è risultato particolarmente utile per verificare il funzionamento dello script in modo completo, attraverso un flag configurabile quando si invoca il task generatore si comunica a Gradle di utilizzare una sorgente locale, nello specifico il nome del pacchetto rpm. In questo modo si può simulare l'installazione del pacchetto, anche se questo non è ancora stato rilasciato all'interno dell'Arch User Repository.

\paragraph{Script} Un discorso differente vale per il repository di Microsoft dalla quale winget reperisce i pacchetti. Come citato nella sezione \ref{chap:winget}, Windows fornisce uno script interattivo capace di inserire ed aggiornare nuovi pacchetti all'interno del repository. Esso permette inoltre di cercare il manifest dell'applicazione già online ed aggiornarlo dallo strumento senza utilizzare file locali. Il comando necessario all'aggiornamento è così formato:

\texttt{wingetcreate update \$packageId --version \$packageVersion \\\tab\tab --urls "\$installerUrl" --submit --token \$gitToken}
\vspace{0.8cm}

Autonomamente lo script: (i) cerca tra i pacchetti disponibili quello indicato da \texttt{\$packageId}, (ii) aggiorna gli attributi dinamici come la versione ed il pacchetto indicati dalle variabili \texttt{\$packageVersion} e \texttt{\$installerUrl}, (iii) utilizza il token GitHub per autenticarsi e richiedere attraverso una pull request l'aggiornamento del pacchetto. Mentre la modifica del pacchetto su \ac{aur} è istantanea, per winget questa deve superare un processo di validazione prima di essere eseguita con successo. Lo script, wingetcreate, in conclusione semplifica il processo e rende obsoleto l'utilizzo del build system, in quanto non è necessario comprendere il manifest del pacchetto all'interno del progetto.


\section{Sviluppo della pipeline}

L'implementazione descritta consente attraverso l'utilizzo del build system di generare i pacchetti ed i corrispondenti meta-dati richiesti per la distribuzione. Il passo successivo è integrare la loro esecuzione all'interno della pipeline, in modo da conseguire gli obiettivi di integrazione e distribuzione continua. La sfida principale consiste nell'inserire i nuovi step senza stravolgere la struttura ed il flusso iniziale. Ciò è ottenibile inserendo nuovi job all'interno della pipeline delegati solamente allo svolgimento di singole e specifiche attività.

\subsection{Generazione degli artefatti}

Innanzitutto, il flusso richiede l'inserimento di nuovi processi incaricati di assemblare e generare gli artefatti richiesti per la distribuzione, ovvero il software impacchettato. Durante l'analisi dello strumento jpackage è stata evidenziata l'assenza del supporto al cross-platform, è necessario quindi delegare a runner con sistemi operativi differenti la generazione degli artefatti. La piattaforma Actions fornisce la possibilità di configurare una \textbf{strategia a matrice}: si determinano dei parametri e una lista dei possibili valori, successivamente in fase di esecuzione saranno eseguiti tanti job quante sono le possibili combinazioni di valori differenti. In questo modo descrivendo un solo job, in fase di esecuzione otteniamo diversi job paralleli i quali svolgono le stesse azioni, ma con un sistema operativo differente. Mediante l'utilizzo del build system richiediamo la generazione dei pacchetti, e successivamente carichiamo l'output utilizzando l'azione \texttt{action/upload-artifact}, quest'ultima permette di trasferire file al di fuori del runner, in modo che successivi job possano scaricare il loro contenuto. Tramite l'attributo \texttt{if} è consentito determinare se uno step deve essere eseguito o saltato dal runner che ha preso in carico l'esecuzione, esso è risultato utile per delegare la generazione dei file JAR a solamente un sistema operativo, dato che gli archivi sono identici essendo codice bytecode e quindi multi-piattaforma.

\lstinputlisting[float,language=Kotlin,label={lst:package-generation}, caption={Il job incaricato alla generazione dei pacchetti}]{listings/package-generation.yml}

Il job non richiede l'esecuzione di azioni preparative, se non l'inizializzazione della pipeline la quale è condotta da \texttt{select-java-version}. In questo modo sfruttiamo le potenzialità del calcolo parallelo per ridurre il tempo di esecuzione della pipeline. Una volta prodotti i pacchetti, questi saranno presi in carico dai successivi job per verificare il loro corretto funzionamento.

\subsection{Test dei processi}

Ogni processo aggiuntivo richiede lo sviluppo di un test apposito. Il fallimento di un qualsiasi test deve bloccare l'esecuzione della pipeline cosicché si garantisce un processo di rilascio completamente funzionante. Questa proprietà si ottiene attraverso lo sviluppo di verifiche di validità dei pacchetti e controlli riguardo la conformità dei meta-dati.

La verifica dei pacchetti richiede l'utilizzo di programmi specifici i quali dipendono dalla tipologia di pacchetto che si vuole analizzare. Utilizzando il build system ed integrando un task specifico \texttt{testJpackageOutput} (\ref{lst:task-jpackage-test}) si collassa la definizione di molteplici job all'interno di un job unico, il quale utilizzando la strategia a matrice definita precedentemente, permette la definizione di un solo insieme di attività poi distribuito su più runner con sistemi operativi differenti. Le procedure di installazione si trovano all'interno del task, il quale conosce il sistema operativo sottostante dunque estrae i pacchetti relativi alla sua piattaforma e controlla la presenza dei file necessari all'utilizzo dell'applicazione. Il task estende la tipologia \texttt{Exec} fornita da Gradle che permette l'esecuzione di comandi nella shell del sistema operativo, in primo luogo configura il comando adibito ad installare il pacchetto a seconda della piattaforma su cui sta eseguendo (il blocco \texttt{doFirst}) ed infine una volta estratti utilizza le API di Kotlin per controllare il filesystem e quindi le cartelle generate durante l'installazione (il blocco \texttt{doLast}).

\lstinputlisting[float,language=Kotlin,label={lst:task-jpackage-test}, caption={Task \texttt{testJpackageOutput} Gradle incaricato di verificare la validità dei pacchetti}]{listings/test-jpackage-task.kt}

Inizialmente il task era posto come dipendente dall'esecuzione di jpackage, in modo che l'esecuzione del test garantisse la presenza dei pacchetti. Questo comportamento tuttavia costringe la generazione dei pacchetti ogniqualvolta si voglia eseguire la verifica. Ciò accade perché il task fornitoci dal plugin \texttt{jpackage-gradle-plugin} non dichiara alcun \textit{output}, quindi Gradle non consente di utilizzare la funzionalità della \textit{build incrementale}. In altre parole, il build system non conosce l'output del task generatore e in caso i pacchetti siano già presenti, come accade nella pipeline perché generati da job precedenti, esso riesegue la generazione sovrascrivendo gli ultimi. La rimozione della dipendenza garantisce un incremento delle prestazioni, permettendo di dividere le attività in due unità di esecuzione differenti. Il costo è una minor chiarezza nell'utilizzo manuale del task, in quanto l'esecuzione del task di verifica senza previa generazione fallirà per l'assenza dei pacchetti. Siccome il test è sviluppato principalmente per l'utilizzo all'interno di pipeline, questa limitazione non genera particolari problematiche, generalmente gli sviluppatori non eseguiranno il task sulla propria macchina, e in caso fosse necessario è sufficiente indicare l'esecuzione del task generatore assieme a quello di verifica.

\section{Valutazione}
% ottimizzazione, fail fast, dipendenze gradle, concurrency group, upload artifact, confronto
