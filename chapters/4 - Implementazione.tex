%!TEX root = ../thesis-main.tex

% Percorso implementativo:
% 	- jpackage e le opzioni in dettaglio
%  	- jlink e jdeps
%   - il plugin gradle per operare con jpackage
%   - la necessità di estendere con jpackageFull
%   - inserimento dei test e della release dei pacchetti
%   - le operazioni per la distribuzione e il test di queste (AUR)

\chapter{Implementazione}

Nel seguente capitolo è illustrato il percorso e le relative scelte implementative effettuate per soddisfare i requisiti posti dal progetto. Successivamente, valuterò il lavoro svolto considerando i requisiti non funzionali posti.

\section{Impacchettamento e distribuzione}

\subsection{Impacchettamento}
Come discusso nelle precedenti sezioni riguardanti lo strumento jpackage (in particolare sezione \ref{sec:design-jpackage}), esso presenta una notevole quantità di opzioni sia inerenti l'aspetto estetico (come nome dell'applicazione, icona, copyright ed altri), sia riguardo aspetti tecnici che possono contraddistinguere la qualità del pacchetto di installazione.
\def\arraystretch{1.5}%  1 is the default, change whatever you need
\begin{table}[htb]\label{tab:jpackage-options}
	\begin{tabular}{|l|l|l|}
		\hline
		\rowcolor[HTML]{ECF4FF} 
		\multicolumn{1}{|c|}{\cellcolor[HTML]{ECF4FF}{\ul Opzione}} &
		\multicolumn{1}{c|}{\cellcolor[HTML]{ECF4FF}{\ul Funzionalità}} &
		\multicolumn{1}{c|}{\cellcolor[HTML]{ECF4FF}{\ul Eventuali parametri}} \\ \hline
		\texttt{--type} &
		Tipologia di pacchetto in output &
		\begin{tabular}[c]{@{}l@{}}rpm, deb, exe, msi, \\ pkg, dmg\end{tabular} \\ \hline
		\texttt{--input} &
		\begin{tabular}[c]{@{}l@{}}Directory contenente i file\\ da impacchettare\end{tabular} &
		Percorso alla directory \\ \hline
		\texttt{--main-jar} &
		\begin{tabular}[c]{@{}l@{}}L'archivio JAR principale\\ contenete la classe principale\end{tabular} &
		Percorso del JAR \\ \hline
		\texttt{--main-class} &
		\begin{tabular}[c]{@{}l@{}}La classe che contiene la \\ funzione di avvio\end{tabular} &
		Nome della classe \\ \hline
		\texttt{--add-modules} &
		\begin{tabular}[c]{@{}l@{}}I moduli integrati nel\\ runtime-image generato da \\ jlink\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}Lista dei moduli separata\\ da ','\end{tabular} \\ \hline
		\texttt{--jlink-options} &
		\begin{tabular}[c]{@{}l@{}}Ulteriori opzioni per\\ l'esecuzione di jlink\end{tabular} &
		Lista delle opzioni \\ \hline
	\end{tabular}
	\caption{Tabella che elenca le principali opzioni tecniche del comando \texttt{jpackage}}
\end{table}

\paragraph{Ottimizzazione} Per comprendere le scelte implementative riguardo le opzioni di carattere tecnico è necessario introdurre altri due strumenti del \ac{jdk}: (i) \texttt{jlink}, strumento delegato alla produzione della \textit{runtime-image} inserita all'interno del pacchetto e (ii) \texttt{jdeps}, comando utilizzabile per analizzare le dipendenze di un archivio JAR. Il primo ha la peculiarità di consentire la creazione di immagini personalizzate contenente solo i componenti necessari per eseguire un'applicazione specifica, riducendo così le dimensioni complessive e incrementando le prestazioni dell'applicazione. Per ottenere i componenti necessari si utilizza il secondo, jdeps, applicato all'archivio JAR contenente l'intera applicazione. In sintesi la generazione del pacchetto richiede l'utilizzo dei tre strumenti a catena come esposto di seguito:
\begin{enumerate}
	\item \texttt{jdeps}, analizza l'archivio contenente la nostra applicazione e restituisce i moduli jvm necessari per il corretto funzionamento di essa.
	\item \texttt{jlink}, utilizza i moduli evidenziati da jdeps per creare una runtime-image personalizzata di dimensioni ridotte
	\item \texttt{jpackage}, utilizza la runtime-image creata precedentemente assieme all'ar\-chi\-vio dell'applicazione per generare il pacchetto: l'application-image.
\end{enumerate}

\lstinputlisting[float,language=Bash,label={lst:jlink-runtime-image-creation}, caption={Comandi eseguiti per creare un java-runtime di dimensioni ridotte}]{listings/jpackage-jlink.sh}

I comandi utilizzati nel processo sono indicati nel listato \ref{lst:jlink-runtime-image-creation}. In particolare l'esecuzione di jdeps coinvolge le seguenti opzioni:
\begin{itemize}
	\item \texttt{--print-module-deps} indica di restituire un output conforme all'input ri\-chie\-sto da jlink (modulo, modulo, ...),
	\item \texttt{--add-modules} aggiunge attraverso la costante ALL-MODULE-PATH tutti i moduli per eseguire l'analisi,
	\item \texttt{--ignore-missing-deps} non restituisce le dipendenze mancanti nell'output,
	\item \texttt{--no-recursive} 
\end{itemize}

jpackage fornisce due opzioni per modificare il comportamento nascosto all'utente di jlink: \texttt{--jlink-options} e \texttt{--add-modules}. Il comando risultante (non comprendente le opzioni estetiche) utilizzando le opzioni descritte nella tabella \ref{tab:jpackage-options} è il seguente:

\texttt{\\ jpackage --input build/package-input \\ \tab\tab --main-jar alchemist-full-VERSION.jar \\ \tab\tab --main-class it.unibo.alchemist.Alchemist \\ \tab\tab --type \{rpm, deb\} \\ \tab\tab --add-modules \\ \tab\tab --jlink-options \\}

%------------------------------------------------

Il design elaborato nel capitolo precedente evidenziava la necessità di un task \textit{wrapper} che incapsulasse le opzioni e funzionalità di jpackage. La versatilità offerta da Gradle ha permesso di ottenere il risultato voluto attraverso \textit{jpackage-gradle-plugin}\footnote{https://github.com/petr-panteleyev/jpackage-gradle-plugin}: un plugin sviluppato dalla comunità. Questo componente introduce un tipo di task \texttt{JPackageTask} capace di: (i) configurare tutte le opzioni supportate da jpackage per qualsiasi versione del \ac{jdk}, (ii) definire blocchi eseguiti solamente su un sistema operativo specifico e (iii) testare le configurazioni attraverso la modalità \textit{dry run}. Il plugin introdotto però, non compensa uno dei limiti di jpackage esposto durante l'analisi dello strumento, ossia la necessità di eseguire il programma molteplici volte per ottenere tutte le tipologie di pacchetti. Per far fronte a questa restrizione, ho creato una tipologia personalizzata (listato \ref{lst:custom-jpackage-task}) estendendo quella fornita dal plugin per modificare il suo comportamento in esecuzione, nello specifico il metodo contrassegnato come \texttt{@TaskAction}.

\lstinputlisting[float,language=Kotlin,label={lst:custom-jpackage-task}, caption={Definizione di un tipo personalizzato per compensare il limite di jpackage}]{listings/custom-jpackage-task.kt}

\paragraph{Risultato}

%Confronto, scelta tra i due full o solo moduli, il guadagno in %, perché in alchemist è così poco ed in altre applicazioni potrebbe essere molto maggiore

\subsection{Distribuzione}

Una volta impacchettato l'applicativo, quest'ultimo è pronto per essere installato e utilizzato dall'utente finale. In un contesto \ac{cicd} è fondamentale eseguire rilasci del software frequentemente, che essi siano aggiornamenti sostanziosi oppure \textit{patch} risolutive di errori o vulnerabilità. Nei paragrafi seguenti saranno esposte le tecniche utilizzate per garantire rilasci consistenti rispettando i requisiti che i repository coinvolti possiedono.

\paragraph{Template} I soli pacchetti non sono sufficienti per pubblicare un applicativo, al contrario molto spesso questi non sono nemmeno necessari dal momento che i meta-dati associati contengono tutto l'occorrente per ottenerli. Quest'ultimi sono file descrittivi che seguono uno schema noto ed espongono le caratteristiche del pacchetto come autore, licenza, copyright, dipendenze e molti altri dettagli facoltativi e non. Spesso inoltre, lo schema richiede la presenza di un collegamento alla sorgente, ossia un \textit{url} localizzante il pacchetto in internet, di modo che non è necessario per i repository ospitare il pacchetto vero e proprio, ma solo un riferimento a questo. La piattaforma GitHub consente al rilascio di una nuova versione di pubblicare \textit{asset} ospitati dalla piattaforma stessa. L'url associato agli asset segue uno schema predefinito rendendolo facilmente riproducibile, come indicato nella figura \ref{fig:github-assets-url}.
\begin{figure}[htb]\label{fig:github-assets-url}
	\centering
	\texttt{https://github.com/<PROPRIETARIO>/<NOME-APPLICATIVO>/\\ \tab releases/download/<VERSIONE>/<NOME-FILE>}
	
	\vspace{0.5cm}
	
	\texttt{https://github.com/AlchemistSimulator/Alchemist/\\ \tab releases/download/30.0.5/alchemist-30.0.5-1.x86\_64.rpm}
	\caption{Schema URL per scaricare un asset da un rilascio GitHub ed esempio di URL localizzante un pacchetto di installazione RPM della versione 30.0.5}
\end{figure}

Come discusso in sezioni precedenti, i pacchetti su Arch Linux e più specificatamente \ac{aur}, sono descritti attraverso un file denominato PKGBUILD, il quale non è altro che uno script bash applicante uno schema predefinito. Tra i vari parametri alcuni di questi necessariamente cambiano ad ogni rilascio: la versione, la sorgente ed il checksum. Per rispondere a queste necessità ho introdotto un task nel build system incaricato di generare lo script PKGBUILD attraverso un \textit{template}. Il task \texttt{generatePKGBUILD} legge un file, detto template, contenente caratteri speciali con la funzione di segnaposto, sostituisce questi con i valori corretti e restituisce in output lo script pronto per essere installato. Nell'ottica di supportare test locali, attraverso un flag è possibile forzare l'inserimento di una sorgente locale, ossia il nome del pacchetto RPM.

Discorso diverso vale per \textbf{winget}

\paragraph{Script}

\section{Automazione}
Lo sezione precedente ha illustrato la generazione dei pacchetti, la preparazione necessaria alla distribuzione di essi e l'integrazione di questi processi all'interno del build system. Quest'ultimo è essenziale per soddisfare il requisito chiave dell'elaborato, l'automazione. 

\subsection{Test}

\subsection{Release}

\section{Valutazione}

- Cosa cambiare, ottimizzazioni