%!TEX root = ../thesis-main.tex

% Percorso implementativo:
% 	V- jpackage e le opzioni in dettaglio
%  	V- jlink e jdeps
%   V- il plugin gradle per operare con jpackage
%   V- la necessità di estendere con jpackageFull
%   - inserimento dei test e della release dei pacchetti
%   - le operazioni per la distribuzione e il test di queste (AUR)

\chapter{Implementazione}

Nel seguente capitolo è illustrato il percorso e le relative scelte implementative effettuate per soddisfare i requisiti posti dal progetto. Successivamente, valuterò il lavoro svolto considerando i requisiti non funzionali posti.

\section{Pacchettizzazione e meta-dati}

\subsection{Pacchettizzazione}
Come discusso nelle precedenti sezioni riguardanti lo strumento jpackage (in particolare sezione \ref{sec:design-jpackage}), esso presenta una notevole quantità di opzioni sia inerenti l'aspetto estetico (nome dell'applicazione, icona, copyright ed altri), sia riguardo aspetti tecnici che possono contraddistinguere la qualità del pacchetto di installazione. Inoltre, attraverso l'\textit{override} delle impostazioni è possibile ottenere un controllo accurato del processo di generazione dei pacchetti, consentendo una totale personalizzazione dell'output generato. Ciò è ottenibile sfruttando due opzioni fornite dall'interfaccia del comando stesso. Eseguendo il programma fornendo l'opzione \texttt{temp}, lo strumento inserisce all'interno della cartella designata i file temporanei utilizzati nel processo (figura \ref{fig:jpackage-process-detailed}). Questi sono i file di configurazione generati dal programma, i quali sono successivamente processati dai toolset specifici per la piattaforma di destinazione per generare il pacchetto. In particolare, ``WiX" è richiesto per la produzione dei pacchetti destinati a Windows, ``XCode" relativamente a MacOs, mentre ``rpm-build" e ``fakeroot" sono necessari per generare rispettivamente pacchetti rpm e deb. La funzionalità di override consiste nel fornire a jpackage i file di configurazione dei toolset, lo strumento pone quest'ultimi sempre come prioritari per stabilire la configurazione del pacchetto in output. Mediante i file temporanei si ottiene una base di partenza nella quale modificare o inserire parametri aggiuntivi. Questa funzionalità ha permesso di soddisfare il requisito \textbf{plug and play}, in particolare è stato implementato l'inserimento automatico dell'eseguibile di Alchemist nella variabile d'ambiente ``Path". In questo modo, l'applicazione è disponibile immediatamente dopo l'installazione e può essere utilizzata da riga di comando senza ulteriori configurazioni.

La capacità di sovrascrivere le configurazioni dei toolset ha permesso di ottenere un maggior controllo sulla forma e comportamento dell'installazione dei pacchetti. Le successive opzioni di carattere tecnico si occupano di modificare il contenuto di questi. In quest'ottica è necessario introdurre altri due strumenti del \ac{jdk}: (i) \texttt{jlink}, strumento delegato alla produzione della \textit{runtime-image} inserita all'interno del pacchetto e (ii) \texttt{jdeps}, comando adibito all'analisi delle dipendenze. Il primo ha la peculiarità di consentire la creazione di ambienti java personalizzati contenenti moduli specifici, riducendo così le dimensioni della runtime-image nel complesso e incrementando le prestazioni dell'applicazione. Per creare una runtime-image ad hoc contenente il minimo necessario ad eseguire l'applicazione si utilizza lo strumento jdeps. In sintesi la generazione del pacchetto richiede l'utilizzo dei tre strumenti consecutivamente come esposto di seguito:
\begin{enumerate}
	\item \texttt{jdeps}, analizza l'archivio contenente l'applicazione e restituisce i moduli java necessari per il corretto funzionamento di essa,
	\item \texttt{jlink}, utilizza i moduli evidenziati da jdeps per creare una runtime-image personalizzata di dimensioni ridotte,
	\item \texttt{jpackage}, utilizza la runtime-image creata precedentemente assieme all'ar\-chi\-vio dell'applicazione per generare il pacchetto: l'application-image.
\end{enumerate}

\lstinputlisting[float,language=Bash,label={lst:jlink-runtime-image-creation}, caption={Comandi eseguiti per creare un java-runtime di dimensioni ridotte}]{listings/jpackage-jlink.sh}

\def\arraystretch{1.5}
\begin{table}[htb]
	\label{fig:jpackage-options}
	\begin{tabular}{|l|l|l|}
		\hline
		\rowcolor[HTML]{ECF4FF} 
		\multicolumn{1}{|c|}{\cellcolor[HTML]{ECF4FF}{\ul Opzione}} &
		\multicolumn{1}{|c|}{\cellcolor[HTML]{ECF4FF}{\ul Funzionalità}} &
		\multicolumn{1}{|c|}{\cellcolor[HTML]{ECF4FF}{\ul Eventuali parametri}} \\ \hline
		\texttt{--type} &
		Tipologia di pacchetto in output &
		\begin{tabular}[c]{@{}l@{}}rpm, deb, exe, msi, \\ pkg, dmg\end{tabular} \\ \hline
		\texttt{--input} &
		\begin{tabular}[c]{@{}l@{}}Directory contenente i file\\ da impacchettare\end{tabular} &
		Percorso alla directory \\ \hline
		\texttt{--main-jar} &
		\begin{tabular}[c]{@{}l@{}}L'archivio JAR principale\\ contenete la classe principale\end{tabular} &
		Percorso del JAR \\ \hline
		\texttt{--main-class} &
		\begin{tabular}[c]{@{}l@{}}La classe che contiene la \\ funzione di avvio\end{tabular} &
		Nome della classe \\ \hline
		\texttt{--add-modules} &
		\begin{tabular}[c]{@{}l@{}}I moduli integrati nel\\ runtime-image generato da \\ jlink\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}Lista dei moduli separata\\ da ','\end{tabular} \\ \hline
		\texttt{--jlink-options} &
		\begin{tabular}[c]{@{}l@{}}Ulteriori opzioni per\\ l'esecuzione di jlink\end{tabular} &
		Lista delle opzioni \\ 
	\end{tabular}
	\caption{Tabella che elenca le principali opzioni tecniche del comando \texttt{jpackage}}
\end{table}

I comandi utilizzati nel processo sono indicati nel listato \ref{lst:jlink-runtime-image-creation}. In particolare l'esecuzione di jdeps coinvolge le seguenti opzioni: \texttt{--print-module-deps} indica di restituire un output conforme all'input ri\-chie\-sto da jlink,\texttt{--add-modules} aggiunge attraverso la costante ``ALL-MODULE-PATH" tutti i moduli per eseguire l'analisi.



Il comando jpackage completo utilizzando le opzioni descritte nella tabella \ref{fig:jpackage-options} è il seguente:

\texttt{\\ jpackage --input build/package-input \\ \tab\tab --main-jar alchemist-full-VERSION.jar \\ \tab\tab --main-class it.unibo.alchemist.Alchemist \\ \tab\tab --add-modules \$DEPENDENCIES \\ \tab\tab --jlink-options no-header-file, no-man-pages \\}

%Confronto, scelta tra i due full o solo moduli, il guadagno in %, perché in alchemist è così poco ed in altre applicazioni potrebbe essere molto maggiore, analisi della reflection step necessario al funzionamento

Il risultato ottenuto è interessante, la differenza tra i due dati è buona.
Il simulatore Alchemist è estendibile, ed ottiene questa caratteristica sfruttando la reflection.

%------------------------------------------------

\paragraph{Plugin} Il design elaborato nel capitolo precedente evidenziava la necessità di un task \textit{wrapper} che incapsulasse le opzioni e funzionalità di jpackage. La versatilità offerta da Gradle ha permesso di ottenere il risultato voluto attraverso \textit{jpackage-gradle-plugin}\footnote{https://github.com/petr-panteleyev/jpackage-gradle-plugin}: un plugin sviluppato dalla comunità. Questo componente introduce un tipo di task \texttt{JPackageTask} capace di: (i) configurare tutte le opzioni supportate da jpackage per qualsiasi versione del \ac{jdk}, (ii) definire blocchi di codice eseguiti solamente su un sistema operativo specifico e (iii) testare le configurazioni attraverso la modalità \textit{dry run}. Tuttavia, il plugin introdotto non risolve uno dei limiti di jpackage evidenziato in fase di analisi: la creazione di un solo pacchetto per l'esecuzione. Per far fronte a questa limitazione, ho creato una tipologia personalizzata (vedi listato \ref{lst:custom-jpackage-task}) che estende quella fornita dal plugin. In questo modo, ho potuto modificare il comportamento del task, intervenendo specificamente sul metodo contrassegnato con \texttt{@TaskAction}. Tale metodo contiene il codice che viene eseguito quando il task viene invocato da riga di comando, avviandone l'esecuzione.

\lstinputlisting[float,language=Kotlin,label={lst:custom-jpackage-task}, caption={Definizione di un tipo di task personalizzato}]{listings/custom-jpackage-task.kt}

\subsection{Meta-dati}

Nei paragrafi seguenti saranno esposte le tecniche utilizzate per garantire l'utilizzo di meta-dati conformi ai requisiti dei repository di destinazione.

\paragraph{Template} I meta-dati associati ai pacchetti presentano attributi statici e altri dinamici. Prendendo in esame il file PKGBUILD, parametri come il nome, la descrizione o le dipendenze non richiedono modifiche tra versioni differenti del software. La modifica di questi è a discrezione dello sviluppatore, il quale come manutentore si occupa per esempio di aggiornare le dipendenze manualmente o modificare le funzioni nel caso dovesse essere necessario. I parametri considerati dinamici invece, richiedono costanti modifiche perché direttamente o indirettamente sono legati alla versione per la quale si sta preparando lo script. Di seguito sono elencati i fondamentali:
\begin{itemize}
	\item la \textbf{versione}, seppure è possibile delegare il calcolo alla funzione \textit{pkgver}, quest'ultima non è ottenibile se non utilizzando il build system. Essendo necessaria l'interazione con Gradle, la scrittura di questo parametro deve essere necessariamente eseguita dinamicamente attraverso esso.
	\item la \textbf{sorgente}, ossia l'URL localizzante il pacchetto in rete. L'aggiornamento ad una nuova versione richiede l'utilizzo del pacchetto contenente la nuova versione del software, ragion per cui l'URL sarà differente.
	\item il \textbf{checksum}, ovvero il codice hash legato alla sorgente. È utilizzato da makepkg per assicurarsi che il pacchetto installato non sia stato sostituito da un attore malevolo, una volta ottenuta la sorgente, ricalcola il checksum e lo confronta con quello fornito dallo script.
\end{itemize}
Mediante l'utilizzo di file detti template è possibile costruire dinamicamente i meta-dati mantenendo una struttura statica facilmente aggiornabile. In particolare, il template del file PKGBUILD contiene tutti i parametri statici correttamente assegnati, mentre quelli dinamici sono identificati attraverso l'inserimento di caratteri speciali inutilizzati. Il task \texttt{generatePKGBUILD} legge il file e sostituisce i caratteri con i valori corretti ottenendo come risultato il PKGBUILD conforme e compatibile con la versione corrente del software.

\paragraph{Script}
% Utilizzo di wingetcreate nella pipeline

\section{Sviluppo della pipeline}

L'implementazione descritta consente attraverso l'utilizzo del build system di generare i pacchetti ed i corrispondenti meta-dati richiesti per la distribuzione. Il passo successivo è integrare la loro esecuzione all'interno della pipeline, in modo da conseguire gli obiettivi di integrazione e distribuzione continua. La sfida principale consiste nell'inserire i nuovi step senza stravolgere la struttura ed il flusso iniziale. Ciò è ottenibile inserendo nuovi job all'interno della pipeline delegati solamente allo svolgimento di singole e specifiche attività.

\subsection{Generazione degli artefatti}

Innanzitutto, il flusso richiede l'inserimento di nuovi processi incaricati di assemblare e generare gli artefatti richiesti per la distribuzione, ovvero il software impacchettato. Durante l'analisi dello strumento jpackage è stata evidenziata l'assenza del supporto al cross-platform, è necessario quindi delegare a runner con sistemi operativi differenti la generazione degli artefatti. La piattaforma Actions fornisce la possibilità di configurare una \textbf{strategia a matrice}: si determinano dei parametri e una lista dei possibili valori, successivamente in fase di esecuzione saranno eseguiti tanti job quante sono le possibili combinazioni di valori differenti. In questo modo descrivendo un solo job, in fase di esecuzione otteniamo diversi job paralleli i quali svolgono le stesse azioni, ma con un sistema operativo differente. Mediante l'utilizzo del build system richiediamo la generazione dei pacchetti, e successivamente carichiamo l'output utilizzando l'azione \texttt{action/upload-artifact}, quest'ultima permette di trasferire file al di fuori del runner, in modo che successivi job possano scaricare il loro contenuto. Tramite l'attributo \texttt{if} è consentito determinare se uno step deve essere eseguito o saltato dal runner che ha preso in carico l'esecuzione, esso è risultato utile per delegare la generazione dei file JAR a solamente un sistema operativo, dato che gli archivi sono identici essendo codice bytecode e quindi multi-piattaforma

\lstinputlisting[float,language=Kotlin,label={lst:package-generation}, caption={Il job incaricato alla generazione dei pacchetti}]{listings/package-generation.yml}

Il job non richiede l'esecuzione di azioni preparative, se non l'inizializzazione della pipeline la quale è condotta da \texttt{select-java-version}. In questo modo sfruttiamo le potenzialità del calcolo parallelo per ridurre il tempo di esecuzione della pipeline. Una volta prodotti i pacchetti, questi saranno presi in carico dai successivi job per verificare il loro corretto funzionamento.

\subsection{Test dei processi}

Nel ruolo di test è necessaria la creazione di diversi job adibiti alla verifica del funzionamento di questi.
% Parla di testJpackageOutput



\section{Valutazione}

% ottimizzazione, fail fast, dipendenze gradle, concurrency group, upload artifact, confronto
